name: {{ .Project }}
description: A binary playbook

# Imports are modules written in Go. The import keys match the modules in
# tasks. The path to the import is the same as in Go, but with the module
# type appended as a suffix.
imports:
  cmd: github.com/cloudboss/go-player/modules/command.Command

# The input schema is a JSON schema for validating input variables. The playbook
# will not accept input variables that do not validate.
input_schema:
  $schema: http://json-schema.org/schema#
  $id: github.com/cloudboss/go-player
  type: object
  properties:
    name:
      type: string
  required:
  - name
  additionalProperties: false

tasks:
- name: hello from an input variable!
  # The name of the module, cmd, must match one of the import keys.
  cmd:
    # The format function behaves like sprintf.
    execute: format("echo Hello %s!", any_var("name"))
  # when_execute() runs its argument and succeeds if the exit status equals 0.
  when: when_execute("/bin/true")

- name: echo the truth
  cmd:
    # The output of this command will be used as the input to when_execute
    # in the next task.
    execute: "echo /bin/true"

- name: run ls command
  cmd:
    execute: "ls /"
  # Here, when_execute() uses the "echo the truth" task output's
  # "stdout" attribute as a command to run.
  when: when_execute(string_output("echo the truth", "stdout"))

- name: run ls command if file doesn't exist
  cmd:
    execute: "ls /"
    # This will never run since / always exists.
    creates: "/"

- name: run a command using another command's output
  cmd:
    execute: |
      format("echo Output of ls command is: %s", any_output("run ls command", "stdout"))
